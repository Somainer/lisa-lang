(import-env! logical) ; (import-env! actors)
(logical/new-context)

(define (create-tts-engine)
    (import-env! system)
    (define is-mac? scala.util.Properties/isMac)
    (define is-windows? scala.util.Properties/isWin)
    (define (mac-command utterance)
        (list "say" utterance))
    (define (windows-command utterance)
        (list "mshta" (string "vbscript:Execute(CreateObject(\"SAPI.SpVoice\").Speak(\"" (.replaceAll utterance "\\s+" ",") "\")(window.close))")))
    (define (linux-command utterance)
        (list "spd-say" (string "\"" utterance "\"")))
    (define (get-command utterance)
        ((cond
            (is-mac? mac-command)
            (is-windows? windows-command)
            (else linux-command)) utterance))
    (define (say utt)
        (say utt false))
    (define (say utt join)
        (apply (if join system system/fork) (get-command utt))
        ())
    say)

(define say (create-tts-engine))

(define (keys-of-record r)
    (.toList (.keys (.record r))))

(define (parse-query (test first))
    (cond
        ((quoted? test) (string "What " test " doses " first " have."))
        ((symbol? first) (string first " are " test "."))
        (else (string "If " first " is " test "."))))
(define (parse-query (relation first second))
    (cond
        ((quoted? relation) (string "The " relation " between " first " and " second "."))
        ((symbol? first) (string first " is " relation " of " second "."))
        (else (string "If " first " is " relation " of " second "."))))
(define (parse-query otherwise) (string otherwise))

(define (parse-fact (attr obj))
    (string obj " is " attr))
(define (parse-fact (relation first second))
    (string first " is " relation " of " second))
(define (parse-fact x) (string x))

(define (parse-rule-body ('and (... xs)))
    (.mkString (map xs parse-rule-body) " and "))
(define (parse-rule-body ('or (... xs)))
    (.mkString (map xs parse-rule-body) " or "))
(define (parse-rule-body ('not x)) (string "not " (parse-rule-body x)))
(define (parse-rule-body x) (parse-fact x))
(define (parse-rule parameter body)
    (string "If " (parse-rule-body body) ", then " (parse-fact parameter) "."))

(define (telling-fact? ('fact _)) true)
(define (telling-fact? _) false)

(define (telling-rule? ('rule _ _)) true)
(define (telling-rule? ('define-rule _ _)) true)
(define (telling-rule? _) false)

(define (generate-one result)
    (define keys (keys-of-record result))
    (define entries (map keys (lambda (key)
        (string key " is " (get result key)))))
    (cond 
        ((= (length keys) 0) "You are god damn right!")
        ((= (length keys) 1) (get result (car keys)))
        (else (.mkString entries "The " " and " "."))))

(define (generate-many results)
    (.mkString (map results generate-one) "They are:" ", " "."))
(define (interpet input result)
    (define len (length result))
    (cond
        ((nil? result) "That's bullshit.")
        ((= len 1) (generate-one (car result)))
        (else (generate-many result))))
(define (solve query)
    (let ((result (run-query query)))
        (interpet query result)))
(define (agent-loop)
    (define text-input (input "Agent>"))
    (define query (if (> (length text-input) 0) (read-string text-input)))
    (cond
        ((nil? query) ())
        ((telling-fact? query)
            (let ((truth (nth query 1)))
                (define parsed-truth (parse-fact truth))
                (add-fact truth)
                (define text (string "Ok, now I know that " parsed-truth "."))
                (println! text)
                (say text)))
        ((telling-rule? query)
            (let (((_ parameter body) query))
                (define parsed-rule (parse-rule parameter body))
                (define text (string "Ok, now I learned that " parsed-rule "."))
                (eval (list 'define-rule parameter body))
                (println! text)
                (say text)))
        (else
            (let ((text (parse-query query)))
                ;(define query-future
                ;    (actors/future &(solve query)))
                (println! "So the question is:" text)
                (say (string "So the question is:" text) true)
                ;(define result (actors/await query-future))
                (define result (solve query))
                (println! result)
                (say result))))
    
    (agent-loop))

(agent-loop)