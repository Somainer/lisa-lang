(define (empty-iterator)
    (define (self 'has-next?) false)
    (define (self 'to-string) "()")
    (define (self 'next) (panic! "Next on empty iterator."))
    self)

(define (head-ite ite (when? (ite 'has-next?)))
    (.[0] (ite 'next)))

(define (tail-ite ite (when? (ite 'has-next?)))
    (.[1] (ite 'next)))

(define (to-string-ite ite (when? (ite 'stated?)))
    (ite 'to-string))

(define (to-string-ite ite (when (ite 'has-next?)))
    (+ "(" (.toString (head-ite ite)) ", ?)"))

(define (to-string-ite _)
    "()")

(define-macro (inherit-ite)
    '(define (self 'to-string) (to-string-ite self)))

(define (seq->iterator (seq))
    (empty-iterator))

(define (seq->iterator (seq head (... tail)))
    (define (self 'has-next?) true)
    (define (self 'next (when (self 'has-next?)))
        (seq head (seq->iterator tail)))
    (inherit-ite)
    self)

(define (cons-ite x ite)
    (define (self 'has-next?) true)
    (define (self 'next)
        (seq x ite))
    self)

(define (concat-ite first second (when (first 'has-next?)))
    (define (self 'has-next?) true)
    (define (self 'next)
        ((lambda ((seq next it))
            (seq next (concat-ite it second))) (first 'next)))
    (inherit-ite)
    self)

(define (concat-ite first second) second)

(define (single-ite x) (cons-ite x (empty-iterator)))

(define (appended-ite ite x)
    (concat-ite ite (single-ite x)))

(define (constant-ite n)
    (define (self 'has-next?) true)
    (define (self 'next)
        (seq n self))
    (define (self 'to-string)
        (+ "(" (.toString n) ", ...)"))
    self)

(define (take n ite)
    (define-mutable! n)
    (define-mutable! r)
    (define-mutable! ite)
    (set! r (seq))
    (while (> n 0)
        (block
            (set! n (- n 1))
            ((lambda ((seq next it))
                (set! r (.appended r (wrap next)))
                (set! ite it)) (ite 'next ))))
    r)

(define (take ite)
    (define-mutable! ite)
    (define-mutable! r)
    (set! r (seq))
    (while (ite 'has-next? )
        ((lambda ((seq next it))
            (set! r (.appended r (wrap next)))
            (set! ite it)) (ite 'next )))
    r)

(define (range from to)
    (define (self 'has-next? ) (< from to))
    (define (self 'next (when (self 'has-next? )))
        (seq from (range (+ from 1) to)))
    (inherit-ite)
    self)

(define (map-ite ite fn)
    (define (self 'has-next? ) (ite 'has-next? ))
    (define (self 'next)
        ((lambda ((seq next it))
            (seq (fn next) (map-ite it fn))) (ite 'next)))
    (inherit-ite)
    self)

(define (zip-ite first second)
    (define (self 'has-next?)
        (if (first 'has-next?)
            (second 'has-next?) false))
    (define (self 'next (when (self 'has-next?)))
        (define first-next (first 'next))
        (define second-next (second 'next))
        (seq (seq (.[0] first-next) (.[0] second-next))
             (zip-ite (.[1] first-next) (.[1] second-next))))
    (inherit-ite)
    self)

(define (zip-with-ite first second fn)
    (map-ite (zip-ite first second) (lambda ((seq a b)) (fn a b))))

(define (reduce-ite ite fn (when (ite 'has-next?)))
    (define-mutable! ite)
    (define-mutable! r)
    (set! r (head-ite ite))
    (set! ite (tail-ite ite))
    (while (ite 'has-next?)
        ((lambda ((seq next it))
            (set! r (fn r next))
            (set! ite it)) (ite 'next)))
    r)

(define sum-ite &(reduce-ite # +))
(define (sum-seq ls)
    (sum-ite (seq->iterator ls)))

(define (stated-ite ite)
    (define-mutable! ite)
    (define (self 'has-next?) (ite 'has-next?))
    (define (self 'stated?) true)
    (define (self 'next (when (self 'has-next?)))
        (define r (ite 'next))
        (set! ite (.[1] r))
        (seq (.[0] r) self))
    (define (self 'to-string) (ite 'to-string))
    self)